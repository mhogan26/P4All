/* lucid implementation of hula load balancing */
// hula algo: 
// probe pkts travel through network, propagating congestion info
// switches track congestion only for best path to a dst through neighboring switch
// switches maintain link util estimate per port
// use amount of time since last update to estimator and a time constant for link util
// flowlet-load balancing, flowlets determined by inter-pkt gap
// load balancing info used when new flowlet arrives at switch


/* consts */
size util_t = 8;
const int<<9>> NUM_PORTS = 255;
size time_t = 48;
const int<<24>> NUM_TORS = 512;
size port_id_t = 9;
const int<<util_t>> PROBE_FREQ_FACTOR = 6;
const int<<time_t>> KEEP_ALIVE_THRESH = 1 <<< PROBE_FREQ_FACTOR;
const int<<time_t>> FLOWLET_TOUT = 1 <<< 3;
// ^ 48w1


/* reg arrays */
// Keep track of the port utilization
global Array.t<<util_t>> port_util = Array.create(NUM_PORTS);
// Last time port_util was updated for a port.
global Array.t<<time_t>> port_util_last_updated = Array.create(NUM_PORTS);
// Keep track of the minimum utilized path
global Array.t<<util_t>> min_path_util = Array.create(NUM_TORS);
// Keep track of the last time a probe from dst_tor came.
global Array.t<<time_t>> update_time = Array.create(NUM_TORS);
// Last time a packet from a flowlet was observed.
global Array.t<<time_t>> flowlet_time = Array.create(1024);
// Best hop for for each tor
global Array.t<<port_id_t>> best_hop = Array.create(NUM_TORS);
// The next hop a flow should take.
global Array.t<<port_id_t>> flowlet_hop = Array.create(1024);


/* events */
entry event hula_in(int srcAddr, int dstAddr, int<<8>> ipv4protocol, int<<16>> srcPort, int<<16>> dstPort, int<<time_t>> curr_time, int<<port_id_t>> ingress_port, int packet_length, int<<util_t>> hdr_path_util);
exit event hula_out(int<<util_t>> hdr_path_util, int<<port_id_t>> egress_port);

/* memops */
memop getf(int memval, int newval){
  return memval;
}
memop setf(int memval, int newval){
  return newval;
}
memop getf_time(int<<time_t>> memval, int<<time_t>> newval){
    return memval;
}
memop setf_time(int<<time_t>> memval, int<<time_t>> newval){
    return newval;
}
memop setf_flow(int<<port_id_t>> memval, int<<port_id_t>> newval) {
    return newval;
}
memop getf_util(int<<util_t>> memval, int<<util_t>> newval){
    return memval;
}
memop update_util(int<<util_t>> memval, int<<util_t>> newval) {
    if (newval < memval) {
        return newval;
    } else {
        return memval;
    }
}

/* functions */
fun int<<util_t>> handle_probe_pkt(int port, int<<24>> dst_tor, int<<util_t>> hdr_path_util, int<<time_t>> curr_time, int<<port_id_t>> ingress_port, int<<util_t>> util) {
    // read from min_path_util, update_time
    //int<<util_t>> mpu = Array.get(min_path_util, dst_tor); 
    //int<<time_t>> up_time = Array.get(update_time, dst_tor);
  
    // if current link util is higher, then it becomes the path util 
    if (hdr_path_util <  util) {
        hdr_path_util = util;
    }

    int<<util_t>> mpu = Array.update(min_path_util, dst_tor, getf_util, 0, update_util, hdr_path_util);

    // if path util from probe is lower than min path util (or entry is expired), update besthop
    //bool cond = (hdr_path_util < mpu || curr_time - up_time > KEEP_ALIVE_THRESH);
    // simplifying ^ cond to remove keepalive piece, so it's compliant w/ tofino
    bool cond = hdr_path_util < mpu;


    // CAN WE DO THIS SYNTAX IN LUCID? --> no :(
    //mpu = cond ? hdr_path_util : mpu;
    //up_time = cond ? curr_time : up_time;
    //if (cond) {
        //mpu = hdr_path_util;
        //up_time = curr_time;
    //}

    if (cond) {
        Array.set(update_time, dst_tor, curr_time);
    }
    // write min_path_util and update_time vals to memory
    //Array.set(min_path_util, dst_tor, mpu);
    //Array.set(update_time, dst_tor, up_time);

    // update best hop if we need to
    //bh_temp = cond ? ingress_port : bh_temp;
    if (cond) { // only change best hop if condition holds, otherwise we leave it
        Array.set(best_hop, dst_tor, ingress_port);
    }
    // min_path_util --> read from and write to hdr.hula.path_util??? (why need to read? can't we just write temp var to hdr field?)
    hdr_path_util = mpu;
    return hdr_path_util;
}

fun int<<port_id_t>> handle_data_pkt(int port, int srcAddr, int dstAddr, int<<8>> ipv4protocol, int<<16>> srcPort, int<<16>> dstPort, int<<24>> dst_tor, int<<time_t>> curr_time, int<<port_id_t>> egress_port, int<<util_t>> util) {
    // hash to get index - base = 32w0, max = 32w1 << 10 - 1 (CAN WE SPECIFY THIS IN LUCID?
    int flow_hash = hash<<32>>(srcAddr, dstAddr, ipv4protocol, srcPort, dstPort);
    // read prev time, store current one
    int<<time_t>> flow_t = Array.update(flowlet_time, flow_hash, getf_time, 0, setf_time, curr_time);

    // if new flowlet (IPG > const), let's use updated best hop val, otherwise use flowlet hop
    //flow_h = (curr_time - flow_t > FLOWLET_TOUT) ? best_h : flow_h;
    int<<port_id_t>> flow_h = 0;
    if (curr_time - flow_t > FLOWLET_TOUT) {
        int<<port_id_t>> best_h = Array.get(best_hop, dst_tor);
        flow_h = Array.update(flowlet_hop, flow_hash, setf_flow, best_h, setf_flow, best_h);

    } else {
        flow_h = Array.get(flowlet_hop, flow_hash);
    }

    // read from flowlet_hop???
    // send data pkt out correct port
    egress_port = flow_h;   

    return egress_port;
}

/* handlers */
handle hula_in(int srcAddr, int dstAddr, int<<8>> ipv4protocol, int<<16>> srcPort, int<<16>> dstPort, int<<time_t>> curr_time, int<<port_id_t>> ingress_port, int packet_length, int<<util_t>> hdr_path_util) {
    // drop???? --> orig p4 code drops all pkts

    // match on dst addr (table populated by control plane), compute dst ToR and id of current switch
    // any way to populate this automatically?
    // we need a topology file that lists names of switches and links between hosts/switches so we know how to populate this table
    // self_id is id of switch
    // for dst_tor, each host is connected to switch (links given in topo file), dst_tor is switch connected to dst host (dst host given by ip) 
    match (dstAddr) with
    | 1862270976 -> {int<<24>> dst_tor = 104; int self_id = 100;}     // placeholder values for now
    | _ -> {int<<24>> dst_tor = 0; int self_id = 1;}    // dummy vals

    /* update stats */
    // read from port_util and port_util_last_updated
    int port = (int<<32>>) ingress_port;
    int<<util_t>> util = Array.get(port_util, port);
    // grab last update time and write back current time
    int<<time_t>> last_update = Array.update(port_util_last_updated, port, getf_time, 0, setf_time, curr_time);

    // subtract last update time from current timestamp
    // WE CAN'T DO THIS IN LUCID - we'd like to put this in a memop, but we have too many variables (delta, packet_length)
    // we need to be able to access metadata (e.g., packet_length) in memop
    int<<util_t>> delta = (int<<util_t>>) (curr_time - last_update);
    util = (( (int<<util_t>>) packet_length + util) <<< PROBE_FREQ_FACTOR ) - delta;
    util = util >>> PROBE_FREQ_FACTOR;

    // write ^ to port_util
    Array.set(port_util, port, util);

    bool drop = false;
    int<<port_id_t>> egress_port = 0;
    /* hula! */
    // hula logic --> match on ipv4 protocol, probe/data/drop
    match (ipv4protocol) with 
    | 0x42 -> {hdr_path_util = handle_probe_pkt(port, dst_tor, hdr_path_util, curr_time, ingress_port, util);}
    | 0x06 -> {egress_port = handle_data_pkt(port, srcAddr, dstAddr, ipv4protocol, srcPort, dstPort, dst_tor, curr_time, egress_port);}
    | _ -> {drop = true;}

    // if valid hula --> standard_metadata.mcast_grp = (bit<16>)standard_metadata.ingress_port; --> IN HARNESS CODE (for now)
    // simple forwarding for edge nodes - if (meta.dst_tor == meta.self_id) --> match on dstAddr, simple forwarding (standard_metadata.egress_spec = port;) or drop
    // we need mapping of switch port -> host (addr) to populate this
    if (dst_tor == self_id) {
        match (dstAddr) with
        | 1862270976 -> {egress_port = 2;} // placeholder values
        | _ -> {drop = true;}
    }

    if (!drop) {
        egress_port = flow_h;
        generate hula_out(hdr_path_util, egress_port);
        // to return --> hdr_path_util?, flow_h (ig_tm_md.ucast_egress_port = flow_h) OR egress_port
    }

}


