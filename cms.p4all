/* ethernet, ipv4 headers, parsing, routing functions */

// assume statements are some target-dependent bounds on symbolic variables
symbolic int stages;
assume();
symbolic int acccesses_stages;  
assume();
symbolic int registers;
assume();

// assume statements should be the minimum value we are willing to accept
// i.e., minimum width/depth to get some accuracy
symbolic int N = stages * accesses_stages;
assume();
symbolic int registers_array = registers/N;
assume();


// NAMING - each index/count should have number (index1, index2, etc.)
// can't construct metadata until know how many values in each stage we're comparing
// what's the right number of counts to store in metadata? = to the total number of accesses we have across all stages or just the max number of accesses in a single stage?
// if the latter, need to compare in each stage??
header_type cms_metadata_t {
    fields {
	for (i = 0; i < N; i++) {
	    bit<11> index;
	    bit<32> count;
	}
	bit<32> count_min;
	bit<32> salt;
    }
}

metadata cms_metadata_t cms_meta;

// hashing - list and calculation
field_list hash_list {
    ipv4.srcAddr;
    ipv4.dstAddr;
    ipv4.protocol;
    cms_meta.salt;
}

field_list_calculation stage_hash {
    input {
        hash_list;
    }
    algorithm : crc16;
    output_width : 11;
}
 

// how to identify what index and metadata count to use if they're defined in for loop?
// how many times can you write to the same metadata value in a stage? - still need at least 2 index/counts if more than one access in same stage

salts = []	// how to populate this? don't know how many you'll end up needing - could just put max number of values in here? and maybe trim based on how many you actually use?
for(i = 0; i < N; i++) {
        register counter {
            width: 32;
            instance_count: registers_array;
        }

        action count(){
	    cms_meta.salt = salts[i];
            /* compute hash index */
	    modify_field_with_hash_based_offset(cms_meta.index, 0, stage_hash, 11);

            /* increment counter  - read, increment, write*/
	    cms_meta.count = counter[cms_meta.index];
	    counter[cms_meta.index] = cms_meta.count + 1;
        }
	// add action to counter table

	action do_find_min(){
	    cms_meta.count_min = cms_meta.count;
	}
	table find_min() {
	    actions { do_find_min; }
	}
}

// ADD COUNT ACTIONS TO TABLE????? EACH ACTION GETS ITS OWN TABLE? OR ACTIONS GO IN SAME TABLE?


control ingress {
    // apply counter table(s) - how many tables do we have?
    apply_tables(counter, ????);

    // finding min - conditions
    // first stage is always the same - put 1st count as min
    apply(find_min1);
    for (i = 0; i < N; i++) {
	if (cms_meta.count_min < cms_meta.count) {
	    apply(find_min);
	}
    }

    /* apply forwarding logic */
}


