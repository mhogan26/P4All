class Conquest_CMS_t(inout headers header, inout custom_metadat_t m, in D keys, in symbolic snapid, in int stepsize, in symbolic cols, in symbolic rows, in func utilfunc) {

    // conquest meta
    struct meta {
	bit<32>[rows] hashed_index_row;
	bit<32>[rows] snap_{snapid}_row_index;
	bit<32>[rows] snap_{snapid}_row_read; 
	bit<32> snap_{snapid}_read_min_l0;
	// LAYER SUM????
    }


    control conquest (...) {

    
        action prep_reads()[i] {
            meta.snap_{snapid}_row_read[i]=0;
        }

        Hash<bit<32>>(HashAlgorithm_t.CRC32)[rows] hash_TCP;
        action calc_hashed_index_TCP()[i] {
            meta.hashed_index_row[i]=hash_TCP[i].get({keys, seeds[i]});
        }


        action snap_{snapid}_select_index_hash() {
	    for (i < rows) {
	        meta.snap_{snapid}_row_index[i]=m.cyclic_index;
	    }
        }

        action snap_{snapid}_select_index_cyclic() {
	    for (i < rows) {
	        meta.snap_{snapid}_row_index[i]=meta.hashed_index_row[i];
	    }
        }

        table tb_snap_{snapid}_select_index {
	    key = {
	        m.snap_epoch: exact;
	    }
	    actions = {
	        snap_{snapid}_select_index_hash;
	        snap_{snapid}_select_index_cyclic;
	    }   
	    size = 2;
	    default_action=snap_{snapid}_select_index_hash;
	    const entries = {
	        {snapid} : snap_{snapid}_select_index_cyclic;
	    }

        }

        // sketch rows
        Register<bit<32>,_>(cols)[rows] snap_{snapid}_row;
        RegisterAction<bit<32>, _, bit<32>> (snap_{snapid}_row[i]) row_read[i] = {
            void apply(inout bit<32> val, out bit<32> rv) {
                rv = val;
            }
        };
        action cms_read()[i] {
            meta.snap_{snapid}_row_read[i]=row_read[i].execute(meta.snap_{snapid}_row_index[i]);
        }

        RegisterAction<bit<32>, _, bit<32>> (snap_{snapid}_row[i]) row_inc[i] = {
            void apply(inout bit<32> val, out bit<32> rv) {
                val = val + 1;
                rv = val;
            }
        };
        action cms_inc()[i] {
            meta.snap_{snapid}_row_read[i]=row_inc.execute(meta.snap_{snapid}_row_index[i]);
        }

        RegisterAction<bit<32>, _, bit<32>> (snap_{snapid}_row[i]) row_clean[i] = {
            void apply(inout bit<32> val, out bit<32> rv) {
                val = 0;
                rv = val;
            }
        };
        action cms_inc()[i] {
            meta.snap_{snapid}_row_read[i]=row_clean.execute(meta.snap_{snapid}_row_index[i]);
        }


        table tb_snap_{snapid}_row_rr [i] {
	    key = {
	        m.snap_epoch: exact;
	        m.num_snapshots_to_read: range;
	    }
	    actions = {
	        cms_read[i];
	        cms_incr[i];
	        cms_clean[i];
	    }
	    const entries = { ... }	// <--- this contains some round robin logic, omitting for now
        }

       apply {
    	    for (i < rows) {
                prep_reads()[i];
	        calc_hashed_index_TCP()[i];
	    }
	    tb_snap_{snapid}_select_index.apply();
	    for (i < rows) {
	        tb_snap_{snapid}_row_rr[i].apply();
	    }

       }


       // utility function
       optimize cms_util {
           function: utilfunc;
           step: stepsize;
       }

    }

}




// this is the main control block, outside of the cms class
symbolic num_snaps;
symbolic cols;
assume(cols>0);
symbolic rows;


// simulations
start(num_snaps=3,cols=2048,rows=3);    // starting values
measure();      // this tells us what to measure in the sim (e.g., observed error rate)
selection();    // function that tells us how to select next values given previous


control MyIngress(inout headers hdr,
                  inout custom_metadata_t meta,
                  inout standard_metadata_t standard_metadata) {

    apply {
        // each iteration of the loop creates a new CMS
	for (i < num_snaps) {
		// get_seed() is a function Danny uses (written in python) that generates a random number
		// can we support something like this in p4all?
		// user could also provide an array of random numbers to use
		c{i} = new Conquest_CMS(hdr, meta, {get_seed(),hdr.ipv4.src_addr,get_seed(),hdr.ipv4.dst_addr,get_seed(),hdr.tcp.src_port,get_seed(),hdr.tcp.dst_port}, i, 100, cols, rows, 3/cols);
	}

        // this is the logic of conquest (reads from, writes to, or cleans sketches)
	for (i < num_snaps) {
		c{i}.conquest.apply();
	}

        // utility function - a summation of the utils from each sketch (snapshot)
        utility conquest_util = 0;
        for (i < num_snaps) {
            conquest_util = conquest_util+c{i}.optimize();
        }
	minimize conquest_util;

    }
}






