/* simple symbolic cms */

// symbolics
symbolic int cols;
symbolic int rows; 

// len of this bounds number of rows we can have in the sketch
// e.g., this limits us to at most 8 rows
// are we allowed to do this in lucid? just using java syntax for now
int[] hash_seeds = {22,33,44,55,66,77,88,99};

// threshold for hh
const int thresh = 100;

// cms structure (keeping reg width fixed for now)
global Array.t<<32>>[rows] cms = [Array.create(cols) for i<rows];


/* extra measurement stuff */
// let's say we know ahead of time we'll have 100 flows, then we can store the approximate min counts in this array
// we can calculate the ground truth flow size outside of the switch (just count the packets in the trace in python code or something)
// then we use this array to easily grab the approx counts to compare against ground truth - maybe we calculate avg error
// we use this extra array for measurement instead of just pulling the vals directly from the cms arrays because we're not storing flow ids in the sketch
// i.e., we won't know which flow is hashed to which register
// this array will have flows stored in order (e.g., flow 1 mapped to index 1)
// we can pass in flow index as an extra header field (that we only need for the interpreter simulations), or we can calc it in the harness p4 code before lucid and save it to metadata
// either way, i don't think we can do it just in lucid because we need to save some state (mapping of pkt hdrs to flow id) --> or can we do this in lucid?
global Array.t<<32>> measure = Array.create(100);


/* Events */
// pkt in switch
entry event ip_in (int<<9>> igr_port, int src, int dst, int flowid, int<<1>> hh);
// end of lucid program, send back to switch
exit event ip_out (int<<9>> egr_port, int src, int dst, int<<1>> hh);


/* Memops */
memop incr(int memval, int incrval) {
	return memval + incrval;
}


/* Handlers */
handle ip_in (int<<9>> igr_port, int src, int dst, int flowid, int<<1>> hh) {
	/* actual cms */
	// init values - is this right? should this go here? can we write this in p4 harness code?
	int min = 0xffffffff;
	hh = 0;

	for (i < rows) {
		// get index
		// log2 --> we don't know how many spaces we're hashing to, so we don't know how many bits to use for index
		// using log2 as a placeholder for now
		int<<log2(cols)>> idx = hash<<log2(cols)>>(hash_seeds[i],src,dst);
		// incr value
		int val = Array.update(cms[i], idx, incr, 1, incr, 1);
		// calculate min as we go
		if (val < min) {
			min = val;
		}
	}

	if (min > thresh) {
		// report to controller or mark packet as heavy hitter or something
		// what we do here will likely be application dependent, but for this example we're marking the packet
		// for simplicity, assume we report every time we get count > thresh
		// in reality, we might want to probabilistically report, or limit the number of times we report a flow (e.g., bloom filter to keep track of if we've already reported)
		hh = 1;
	}

	/* measurement stuff */
	// just write to array for now, and maybe we pull these vals after running simulation to get avg error
	Array.set(measure, flowid, min);

	generate ip_out(igr_port, src, dst, hh);
}
